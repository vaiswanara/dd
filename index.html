<!DOCTYPE html>
<html lang="te">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DHARMAVARAM DYNASTY(Family Tree PWA)</title>

    <meta name="theme-color" content="#3498db">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            text-align: center;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .header {
            background: #fff;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }

        .breadcrumbs {
            width: 100%;
            text-align: left;
            font-size: 12px;
            color: #37516a;
            background: #f6fbff;
            border: 1px solid #d8e8f5;
            border-radius: 8px;
            padding: 6px 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        h1 { margin: 0; font-size: 1.2rem; color: #2c3e50; margin-right: 20px; }

        input[type="file"] {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .search-box { position: relative; }

        #searchInput {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            width: 200px;
            transition: width 0.3s;
        }
        #searchInput:focus { width: 250px; border-color: #3498db; }

        .search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
            text-align: left;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .search-dropdown div { padding: 10px; cursor: pointer; border-bottom: 1px solid #eee; color: #333; }
        .search-dropdown div:hover { background-color: #f0f2f5; color: #3498db; }

        .search-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .tree-wrapper {
            width: 100vw;
            height: 100vh;
            overflow: auto;
            padding-top: 86px;
            box-sizing: border-box;
            cursor: grab;
            touch-action: none;
        }

        .tree {
            white-space: nowrap;
            padding: 50px;
            display: inline-block;
            min-width: 100%;
        }

        .tree ul {
            padding-top: 20px;
            position: relative;
            transition: max-height 0.28s ease, opacity 0.28s ease, transform 0.28s ease;
            display: flex;
            justify-content: center;
            transform-origin: top center;
        }

        .tree li {
            float: left;
            text-align: center;
            list-style-type: none;
            position: relative;
            padding: 20px 5px 0 5px;
            transition: all 0.5s;
        }

        .tree li::before, .tree li::after {
            content: '';
            position: absolute;
            top: 0;
            right: 50%;
            border-top: 2px solid #ccc;
            width: 50%;
            height: 20px;
        }
        .tree li::after { right: auto; left: 50%; border-left: 2px solid #ccc; }
        .tree li:only-child::after, .tree li:only-child::before { display: none; }
        .tree li:only-child { padding-top: 0; }
        .tree li:first-child::before, .tree li:last-child::after { border: 0 none; }
        .tree li:last-child::before { border-right: 2px solid #ccc; border-radius: 0 5px 0 0; }
        .tree li:first-child::after { border-radius: 5px 0 0 0; }
        .tree ul ul::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            border-left: 2px solid #ccc;
            width: 0;
            height: 20px;
        }

        .node-container {
            display: inline-block;
            position: relative;
            z-index: 2;
        }

        .member-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #fff;
            border: 3px solid #3498db;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            cursor: pointer;
            font-weight: bold;
            color: #3498db;
            font-size: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: all 0.3s;
        }
        .member-circle:hover { background-color: #e8f4ff; }

        .member-name {
            margin-top: 15px;
            font-size: 14px;
            color: #000;
            font-weight: 600;
            background: rgba(255,255,255,0.9);
            padding: 2px 5px;
            border-radius: 4px;
            min-width: 120px;
            white-space: normal;
            line-height: 1.2;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .spouse-name {
            display: inline-block;
            font-size: 11px;
            color: #a84600;
            margin-top: 5px;
            font-weight: 700;
            white-space: normal;
            line-height: 1.1;
            background: #fff3e6;
            border: 1px solid #ffd4ad;
            border-radius: 999px;
            padding: 3px 8px;
            max-width: 170px;
        }

        .circle-wrapper { position: relative; display: inline-block; }

        .toggle-btn {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #2c3e50;
            color: #fff;
            border-radius: 50%;
            font-size: 18px;
            line-height: 18px;
            cursor: pointer;
            display: none;
            border: 2px solid #fff;
            font-weight: bold;
            align-items: center;
            justify-content: center;
            z-index: 20;
            user-select: none;
        }

        .tree li.has-children > .node-container .toggle-btn { display: flex; }
        .tree li > ul {
            max-height: 2400px;
            opacity: 1;
            transform: translateY(0);
            overflow: hidden;
        }
        .tree li.collapsed > ul {
            max-height: 0;
            opacity: 0;
            transform: translateY(-6px);
            pointer-events: none;
        }
        .tree li.collapsed > .node-container .toggle-btn { background-color: #27ae60; }
        .tree li.expanded > .node-container .toggle-btn { background-color: #2c3e50; }
        .tree li.collapsed > .node-container .toggle-btn::after { content: '+'; }
        .tree li.expanded > .node-container .toggle-btn::after { content: '-'; position: relative; top: -1px; }

        .highlight .member-circle {
            background-color: #f1c40f;
            border-color: #f39c12;
            color: #fff;
            box-shadow: 0 0 20px #f1c40f;
        }

        .tree li.lineage > .node-container .member-circle {
            border-color: #1f7a8c;
            box-shadow: 0 0 0 3px rgba(31, 122, 140, 0.15);
        }

        .tree li.selected > .node-container .member-circle {
            border-color: #f39c12;
            box-shadow: 0 0 0 4px rgba(243, 156, 18, 0.2);
            background: #fff8e8;
        }

        .profile-card {
            position: fixed;
            z-index: 2000;
            min-width: 210px;
            max-width: 280px;
            background: #fff;
            border: 1px solid #d9e2ec;
            border-radius: 10px;
            box-shadow: 0 10px 24px rgba(0,0,0,0.12);
            padding: 10px 12px;
            text-align: left;
            pointer-events: none;
            display: none;
        }

        .profile-card .pc-title {
            font-size: 13px;
            font-weight: 700;
            color: #1f2d3d;
            margin-bottom: 8px;
        }

        .profile-card .pc-row {
            font-size: 12px;
            color: #334e68;
            margin: 3px 0;
            line-height: 1.3;
        }

        @media (max-width: 600px) {
            .header { flex-direction: column; padding: 10px; }
            .search-box, #searchInput { width: 100% !important; }
            .tree-wrapper { padding-top: 150px; }
            .tree { padding: 16px 8px; }
            .tree li { padding: 10px 3px 0 3px; }
            .tree ul { padding-top: 14px; }
            .member-circle { width: 42px; height: 42px; font-size: 14px; border-width: 2px; }
            .member-name { margin-top: 8px; min-width: 82px; max-width: 94px; font-size: 11px; line-height: 1.15; }
            .spouse-name { font-size: 10px; max-width: 120px; padding: 2px 6px; }
            .breadcrumbs { font-size: 11px; }
            h1 { margin-right: 0; margin-bottom: 10px; }
            #uploadSection { margin-bottom: 10px; }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>DHARMAVARAM DYNASTY</h1>
        <div id="uploadSection">
            <input type="file" id="csvFileInput" accept=".csv">
        </div>
        <div class="search-box">
            <input type="text" id="searchInput" placeholder="Search name..." autocomplete="off">
            <div id="searchDropdown" class="search-dropdown"></div>
            <button class="search-btn" onclick="searchNode(document.getElementById('searchInput').value)">Search</button>
        </div>
        <div id="breadcrumbBar" class="breadcrumbs">Path: Home</div>
    </div>

    <div class="tree-wrapper" id="mainWrapper">
        <div class="tree" id="treeContainer"></div>
    </div>
    <div id="profileCard" class="profile-card" aria-hidden="true"></div>

    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(() => console.log('Service Worker Registered'));
        }

        const HOME_MEMBER_NAME = 'SRIKANTH DHARMAVARAM';

        let allData = [];
        let rootNodes = [];
        let dataMap = {};
        let activeFocusId = null;
        const profileCard = document.getElementById('profileCard');
        const breadcrumbBar = document.getElementById('breadcrumbBar');

        window.addEventListener('DOMContentLoaded', () => {
            fetch('family_data.csv')
                .then(r => r.text())
                .then(text => {
                    allData = parseCSV(text);
                    rootNodes = buildHierarchy(allData);
                    renderTree(rootNodes);
                    document.getElementById('uploadSection').style.display = 'none';

                    const homeNode = Object.values(dataMap).find(n => n.name === HOME_MEMBER_NAME);
                    if (homeNode) locateNode(homeNode.id);
                })
                .catch(e => console.log('Auto-load failed. Use manual upload.', e));
        });

        document.getElementById('csvFileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(evt) {
                const text = evt.target.result;
                allData = parseCSV(text);
                rootNodes = buildHierarchy(allData);
                activeFocusId = null;
                renderTree(rootNodes);
            };
            reader.readAsText(file);
        });

        document.getElementById('searchInput').addEventListener('keyup', function(e) {
            if (e.key === 'Enter') searchNode(this.value);
        });

        const searchInput = document.getElementById('searchInput');
        const searchDropdown = document.getElementById('searchDropdown');

        searchInput.addEventListener('input', function() {
            const query = this.value.toLowerCase();
            searchDropdown.innerHTML = '';
            if (query.length < 1) {
                searchDropdown.style.display = 'none';
                return;
            }

            const matches = Object.values(dataMap)
                .filter(p => p.name && p.name.toLowerCase().includes(query))
                .slice(0, 10);

            if (matches.length > 0) {
                matches.forEach(p => {
                    const div = document.createElement('div');
                    div.textContent = p.name;
                    div.onclick = () => {
                        searchInput.value = p.name;
                        searchDropdown.style.display = 'none';
                        locateNode(p.id);
                    };
                    searchDropdown.appendChild(div);
                });
                searchDropdown.style.display = 'block';
            } else {
                searchDropdown.style.display = 'none';
            }
        });

        document.addEventListener('click', function(e) {
            if (!document.querySelector('.search-box').contains(e.target)) {
                searchDropdown.style.display = 'none';
            }

            if (!e.target.closest('.member-circle') && !e.target.closest('#profileCard')) {
                hideProfileCard();
            }
        });
i
        document.getElementById('mainWrapper').addEventListener('scroll', hideProfileCard);

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const result = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const parts = [];
                let current = '';
                let inQuote = false;

                for (const char of line) {
                    if (char === '"') { inQuote = !inQuote; continue; }
                    if (char === ',' && !inQuote) {
                        parts.push(current.trim());
                        current = '';
                        continue;
                    }
                    current += char;
                }
                parts.push(current.trim());

                if (parts.length < 2) continue;

                result.push({
                    id: parts[0],
                    name: parts[1],
                    fid: parts[2] || null,
                    mid: parts[3] || null,
                    pids: parts[4]
                        ? [...new Set(parts[4].split(',').map(s => s.trim()).filter(Boolean))]
                        : []
                });
            }
            return result;
        }

        function buildHierarchy(flatData) {
            dataMap = {};
            flatData.forEach(node => {
                dataMap[node.id] = { ...node, children: [], collapsed: true, parent: null, parents: [] };
            });

            const roots = [];
            flatData.forEach(node => {
                const parentIds = [...new Set([node.fid, node.mid].filter(pid => pid && dataMap[pid]))];
                const displayParentId = parentIds[0] || null;

                if (parentIds.length > 0) {
                    dataMap[node.id].parents = parentIds.map(pid => dataMap[pid]);
                }

                if (displayParentId && dataMap[displayParentId]) {
                    dataMap[displayParentId].children.push(dataMap[node.id]);
                    dataMap[node.id].parent = dataMap[displayParentId];
                } else {
                    roots.push(dataMap[node.id]);
                }
            });

            return roots;
        }

        function toggleNode(id) {
            if (dataMap[id]) {
                const wasCollapsed = dataMap[id].collapsed;
                dataMap[id].collapsed = !dataMap[id].collapsed;
                renderTree(rootNodes);
                if (wasCollapsed) {
                    setTimeout(() => centerNodeFamily(id), 120);
                }
            }
        }

        function centerNodeFamily(id) {
            const wrapper = document.getElementById('mainWrapper');
            const nodeEl = document.getElementById(`node-${id}`);
            if (!wrapper || !nodeEl) return;

            const wrapperRect = wrapper.getBoundingClientRect();
            const nodeRect = nodeEl.getBoundingClientRect();

            let left = nodeRect.left;
            let right = nodeRect.right;
            let top = nodeRect.top;
            let bottom = nodeRect.bottom;

            const directChildrenList = nodeEl.querySelector(':scope > ul');
            if (directChildrenList && directChildrenList.offsetHeight > 0) {
                const childrenRect = directChildrenList.getBoundingClientRect();
                left = Math.min(left, childrenRect.left);
                right = Math.max(right, childrenRect.right);
                top = Math.min(top, childrenRect.top);
                bottom = Math.max(bottom, childrenRect.bottom);
            }

            const targetCenterX = (left + right) / 2;
            const targetCenterY = (top + bottom) / 2;

            const nextLeft = wrapper.scrollLeft + (targetCenterX - wrapperRect.left) - (wrapper.clientWidth / 2);
            const nextTop = wrapper.scrollTop + (targetCenterY - wrapperRect.top) - (wrapper.clientHeight / 2);

            wrapper.scrollTo({
                left: Math.max(0, nextLeft),
                top: Math.max(0, nextTop),
                behavior: 'smooth'
            });
        }

        function formatName(name) {
            if (!name) return '';
            const parts = name.trim().split(/\s+/);
            if (parts.length > 1) {
                const firstPart = parts.slice(0, -1).join(' ');
                const lastPart = parts[parts.length - 1];
                return `${firstPart}.${lastPart.charAt(0)}`;
            }
            return name;
        }

        function createTreeHTML(node) {
            const hasChildren = node.children && node.children.length > 0;
            const collapsedClass = node.collapsed ? 'collapsed' : 'expanded';
            const childrenClass = hasChildren ? 'has-children' : '';
            const initial = node.name ? node.name.charAt(0).toUpperCase() : '?';

            let spouseHtml = '';
            if (node.pids && node.pids.length > 0) {
                const spouseNames = node.pids.map(pid => {
                    const spouseNode = dataMap[pid];
                    return spouseNode ? formatName(spouseNode.name) : '';
                }).filter(Boolean);

                if (spouseNames.length > 0) {
                    spouseHtml = `<div class="spouse-name">(${spouseNames.join(', ')})</div>`;
                }
            }

            let html = `<li class="${collapsedClass} ${childrenClass}" id="node-${node.id}">
                <div class="node-container">
                    <div class="circle-wrapper">
                        <div class="member-circle"
                             onclick="toggleNode('${node.id}')"
                             onmouseenter="showProfileCard('${node.id}', event)"
                             onmouseleave="hideProfileCard()"
                             ontouchstart="showProfileCard('${node.id}', event)"
                             title="${node.name || ''}">
                            ${initial}
                        </div>
                        <div class="toggle-btn" onmousedown="event.stopPropagation()" onclick="event.stopPropagation(); toggleNode('${node.id}')"></div>
                    </div>
                    <div class="member-name">${formatName(node.name)}</div>
                    ${spouseHtml}
                </div>`;

            if (hasChildren) {
                html += '<ul>';
                node.children.forEach(child => {
                    html += createTreeHTML(child);
                });
                html += '</ul>';
            }

            html += '</li>';
            return html;
        }

        function renderTree(roots) {
            const container = document.getElementById('treeContainer');
            if (roots.length === 0) {
                container.innerHTML = '';
                return;
            }

            let htmlContent = '<ul>';
            roots.forEach(root => htmlContent += createTreeHTML(root));
            htmlContent += '</ul>';
            container.innerHTML = htmlContent;
            applyLineageFocus(activeFocusId);
        }

        let searchResults = [];
        let searchIndex = 0;
        let lastQuery = '';

        function expandAncestors(node) {
            if (!node) return;
            const visited = new Set();
            const stack = [node];

            while (stack.length > 0) {
                const current = stack.pop();
                if (!current || visited.has(current.id)) continue;
                visited.add(current.id);

                const parents = current.parents && current.parents.length > 0
                    ? current.parents
                    : (current.parent ? [current.parent] : []);

                parents.forEach(parentNode => {
                    parentNode.collapsed = false;
                    stack.push(parentNode);
                });
            }
        }

        function getLineageIds(node) {
            if (!node) return new Set();
            const lineage = new Set();
            const stack = [node];

            while (stack.length > 0) {
                const current = stack.pop();
                if (!current || lineage.has(current.id)) continue;
                lineage.add(current.id);

                const parents = current.parents && current.parents.length > 0
                    ? current.parents
                    : (current.parent ? [current.parent] : []);

                parents.forEach(parentNode => stack.push(parentNode));
            }

            return lineage;
        }

        function getFocusPath(node) {
            const path = [];
            let current = node;
            while (current) {
                path.push(current);
                current = current.parent || null;
            }
            return path.reverse();
        }

        function updateBreadcrumb(focusId) {
            if (!focusId || !dataMap[focusId]) {
                breadcrumbBar.textContent = 'Path: Home';
                return;
            }

            const pathNames = getFocusPath(dataMap[focusId]).map(n => n.name || n.id);
            breadcrumbBar.textContent = `Path: ${pathNames.join(' > ')}`;
        }

        function getDisplayNames(ids) {
            if (!ids || ids.length === 0) return 'N/A';
            const names = ids.map(id => dataMap[id]?.name).filter(Boolean);
            return names.length > 0 ? names.join(', ') : 'N/A';
        }

        function getParentNames(node) {
            const parentIds = [node.fid, node.mid].filter(Boolean);
            return getDisplayNames(parentIds);
        }

        function showProfileCard(id, event) {
            const node = dataMap[id];
            if (!node) return;

            const spouseNames = getDisplayNames(node.pids || []);
            const parentNames = getParentNames(node);
            const childrenCount = node.children ? node.children.length : 0;

            profileCard.innerHTML = `
                <div class="pc-title">${node.name || 'Unknown'}</div>
                <div class="pc-row"><strong>ID:</strong> ${node.id}</div>
                <div class="pc-row"><strong>Parents:</strong> ${parentNames}</div>
                <div class="pc-row"><strong>Spouse(s):</strong> ${spouseNames}</div>
                <div class="pc-row"><strong>Children:</strong> ${childrenCount}</div>
            `;

            const pointerX = event.clientX || (event.touches && event.touches[0]?.clientX) || 0;
            const pointerY = event.clientY || (event.touches && event.touches[0]?.clientY) || 0;
            const cardWidth = 280;
            const left = Math.min(window.innerWidth - cardWidth - 12, Math.max(12, pointerX + 14));
            const top = Math.min(window.innerHeight - 180, Math.max(12, pointerY + 14));

            profileCard.style.left = `${left}px`;
            profileCard.style.top = `${top}px`;
            profileCard.style.display = 'block';
            profileCard.setAttribute('aria-hidden', 'false');
        }

        function hideProfileCard() {
            profileCard.style.display = 'none';
            profileCard.setAttribute('aria-hidden', 'true');
        }

        function applyLineageFocus(focusId) {
            const container = document.getElementById('treeContainer');
            container.querySelectorAll('li.lineage').forEach(el => el.classList.remove('lineage'));
            container.querySelectorAll('li.selected').forEach(el => el.classList.remove('selected'));

            if (!focusId || !dataMap[focusId]) {
                updateBreadcrumb(null);
                return;
            }
            const lineageIds = getLineageIds(dataMap[focusId]);

            lineageIds.forEach(id => {
                const el = document.getElementById(`node-${id}`);
                if (el) el.classList.add('lineage');
            });

            const selected = document.getElementById(`node-${focusId}`);
            if (selected) selected.classList.add('selected');
            updateBreadcrumb(focusId);
        }

        function focusNode(foundId) {
            activeFocusId = foundId;
            expandAncestors(dataMap[foundId]);
            renderTree(rootNodes);

            setTimeout(() => {
                const element = document.getElementById(`node-${foundId}`);
                if (element) {
                    document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
                    element.classList.add('highlight');
                    element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                }
            }, 100);
        }

        function searchNode(name) {
            if (!name) return;
            const lowerName = name.toLowerCase();

            if (lowerName !== lastQuery) {
                searchResults = Object.keys(dataMap).filter(id =>
                    dataMap[id].name && dataMap[id].name.toLowerCase().includes(lowerName)
                );
                searchIndex = 0;
                lastQuery = lowerName;
            } else {
                searchIndex++;
                if (searchIndex >= searchResults.length) searchIndex = 0;
            }

            if (searchResults.length > 0) {
                const foundId = searchResults[searchIndex];
                focusNode(foundId);
                document.getElementById('searchInput').title = `Result ${searchIndex + 1} of ${searchResults.length}`;
            } else {
                alert('Name not found');
            }
        }

        function locateNode(id) {
            if (!dataMap[id]) return;
            focusNode(id);
        }

        const slider = document.getElementById('mainWrapper');
        let isDragging = false;
        let dragPointerId = null;
        let startX = 0;
        let startY = 0;
        let scrollLeft = 0;
        let scrollTop = 0;

        slider.addEventListener('pointerdown', (e) => {
            if (e.button !== 0 && e.pointerType === 'mouse') return;
            if (e.target.closest('.toggle-btn') || e.target.closest('.search-box')) return;

            isDragging = true;
            dragPointerId = e.pointerId;
            slider.setPointerCapture(e.pointerId);
            slider.style.cursor = 'grabbing';
            slider.style.userSelect = 'none';
            startX = e.clientX;
            startY = e.clientY;
            scrollLeft = slider.scrollLeft;
            scrollTop = slider.scrollTop;
        });

        slider.addEventListener('pointermove', (e) => {
            if (!isDragging || dragPointerId !== e.pointerId) return;
            e.preventDefault();
            const walkX = e.clientX - startX;
            const walkY = e.clientY - startY;
            slider.scrollLeft = scrollLeft - walkX;
            slider.scrollTop = scrollTop - walkY;
        });

        function endDrag(e) {
            if (!isDragging || dragPointerId !== e.pointerId) return;
            isDragging = false;
            dragPointerId = null;
            slider.style.cursor = 'grab';
            slider.style.userSelect = '';
            if (slider.hasPointerCapture(e.pointerId)) {
                slider.releasePointerCapture(e.pointerId);
            }
        }

        slider.addEventListener('pointerup', endDrag);
        slider.addEventListener('pointercancel', endDrag);
    </script>
</body>
</html>
